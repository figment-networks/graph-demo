"use strict";
exports.__esModule = true;
exports.BlockEntity = void 0;
var graph_1 = require("../graph");
/***
 * Generated
 * Definitions here would be auto-generated by `graph codegen`
 */
var BlockEntity = /** @class */ (function () {
    function BlockEntity() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        Object.assign(this, args);
    }
    return BlockEntity;
}());
exports.BlockEntity = BlockEntity;
// callGQL returns string. Parse that to JSON object
function query(network, query, args, version) {
    var stringResponse = graph_1.callGQL(network, query, args, version);
    graph_1.printA('GQL call raw response: ' + JSON.stringify(stringResponse));
    return JSON.parse(stringResponse);
}
/**
 * Mapping
 */
var GET_BLOCK = "query GetBlock($height: Int) {\n  block( $height: Int = 0 ) {\n    height\n    time\n    id\n  }\n}";
/**
 * This would be defined in the subgraph.yaml.
 *
 * Ex:
 * ```yaml
 * # ...
 * mapping:
 *  kind: cosmos/events
 *  apiVersion: 0.0.1
 *  language: wasm/assemblyscript
 *  blockHandlers:
 *    - function: handleNewBlock
 * ```
 */
function handleNewBlock(newBlockEvent) {
    graph_1.printA('newEventData: ' + JSON.stringify(newBlockEvent));
    var _a = query(newBlockEvent.network, GET_BLOCK, { height: newBlockEvent.height }, "0.0.1"), error = _a.error, data = _a.data;
    if (error) {
        graph_1.printA('GQL call error: ' + JSON.stringify(error));
        return;
    }
    if (!data) {
        graph_1.printA('GQL call returned no data');
        return;
    }
    graph_1.printA('GQL call data: ' + JSON.stringify(data));
    var height = data.height, id = data.id, time = data.time;
    var entity = new BlockEntity(height, id, time, "ok");
    graph_1.printA('Entity: ' + JSON.stringify(entity));
    // replace with `entity.save()` for graph-ts
    graph_1.storeRecord("SubgraphStoreBlock", entity);
}
