"use strict";
exports.__esModule = true;
var graph_1 = require("../../graph");
/***
 * Generated
 * Definitions here would be auto-generated by `graph codegen`
 */
var TransactionEntity = /** @class */ (function () {
    function TransactionEntity() {
        Object.assign(this, arguments);
    }
    TransactionEntity.prototype.save = function () {
        return graph_1.store.save("Transaction", this);
    };
    return TransactionEntity;
}());

var BlockEntity = /** @class */ (function () {
    function BlockEntity() {
        // var args = [];
        // for (var _i = 0; _i < arguments.length; _i++) {
        //     args[_i] = arguments[_i];
        // }
        Object.assign(this, arguments);
    }
    BlockEntity.prototype.save = function () {
        return graph_1.store.save("Block", this);
    };
    return BlockEntity;
}());
/**
 * Mapping
 */
const GET_BLOCK = `query GetBlock($height: Int = 0, $chain_id: String = "mainnet") {
    block( height: $height, chain_id: $chain_id) {
      hash
      height
      time
    }
  }`;
/**
 * This function is defined in the subgraph.yaml.
 *
 * Ex:
 * ```yaml
 * # ...
 * mapping:
 *  kind: cosmos/blocks
 *  apiVersion: 0.0.1
 *  language: wasm/assemblyscript
 *  transactionHandlers:
 *    - function: handleTransaction
 *  blockHandlers:
 *    - function: handleBlock
 * ```
 */
function handleBlock(newBlockEvent) {
    graph_1.log.debug('newBlockEvent: ', JSON.stringify(newBlockEvent));
    var _a = graph_1.graphql.call("cosmos", GET_BLOCK, { height: newBlockEvent.height, chain_id: "cosmoshub-4" }, "0.0.1"), error = _a.error, data = _a.data;
    if (error) {
        graph_1.log.debug('GQL call error: ', JSON.stringify(error));
        return;
    }
    if (!data) {
        graph_1.log.debug('GQL call returned no data');
        return;
    }
    graph_1.log.debug('GQL call data: ', JSON.stringify(data));
    var id = newBlockEvent.id;
    var block = data.block;
    var hash = block.hash, height = block.height, time = block.time;
    var entity = new BlockEntity({ id, hash, height,  myNote: "ok", time })
    graph_1.log.debug('Entity: ', JSON.stringify(entity));
    var result = entity.save();
    if (result) {
        graph_1.log.debug('Error storing block: ', JSON.stringify(result.storeErr));
    } else {
        graph_1.log.debug('Block stored: ', JSON.stringify(newBlockEvent));
    }
}

var GET_TRANSACTIONS = `query GetTransactions($height: Int = 0, $chain_id: String = "mainnet") {
    transactions(height: $height, chain_id: $chain_id) {
      hash
      height
      time
    }
  }`;

function handleTransaction(newTxnEvent) {
    graph_1.log.debug('newTxnEvent: ', JSON.stringify(newTxnEvent));
    var _a = graph_1.graphql.call("cosmos", GET_TRANSACTIONS, { height: newTxnEvent.height, chain_id: "cosmoshub-4" }, "0.0.1"), error = _a.error, data = _a.data;
    if (error) {
        graph_1.log.debug('GQL call error: ', JSON.stringify(error));
        return;
    }
    if (!data) {
        graph_1.log.debug('GQL call returned no data');
        return;
    }
    graph_1.log.debug('GQL call data: ', JSON.stringify(data));
    var blockID = newTxnEvent.block_id;
    var txIDs = newTxnEvent.tx_ids;
    var txIDsLen = txIDs.length;
    data.transactions.forEach((tx, idx) => {
        if (idx >= txIDsLen) {
            graph_1.log.debug('Transaction ids slice is too short: ', txIDsLen);
            return;
        }

        var hash = tx.hash, height = tx.height, time = tx.time, id = txIDs[idx];
        var entity = new TransactionEntity({ id, blockID, hash, height, myNote: "ok", time })
        graph_1.log.debug('Entity: ', JSON.stringify(entity));
        var result = entity.save();
        if (result) {
            graph_1.log.debug('Error storing transaction: ', JSON.stringify(result.storeErr));
        } else {
            graph_1.log.debug('Transaction stored: ', JSON.stringify(tx));
        }
    });
}
