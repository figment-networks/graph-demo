
import { graphql, BlockEvent, store, log, TransactionEvent, Network } from "../../graph";

/***
 * Generated
 * Definitions here would be auto-generated by `graph codegen`
 */
 class TransactionEntity {
  id: string;
  height: number;
  hash: string;
  time: Date;
  myNote: string;

  constructor(args) {
    Object.assign(this, args);
  }

  save() {
    return store.save("Transaction", this);
  }
}

 class BlockEntity {
   id: string;
   height: number;
   hash: string;
   time: Date;
   myNote: string;
   transactions: TransactionEntity[];

  constructor(args) {
    Object.assign(this, args);
  }

  save() {
    return store.save("Block", this);
  }
}

/**
 * Mapping
 */
const GET_BLOCK = `query GetBlock($height: Int = 0, $chain_id: String = "mainnet") {
  block( height: $height, chain_id: $chain_id) {
    hash
    height
    time
  }
}`;

/**
 * This function is defined in the subgraph.yaml.
 *
 * Ex:
 * ```yaml
 * # ...
 * mapping:
 *  kind: cosmos/blocks
 *  apiVersion: 0.0.1
 *  language: wasm/assemblyscript
 *  transactionHandlers:
 *    - function: handleTransaction
 *  blockHandlers:
 *    - function: handleBlock
 * ```
 */
function handleBlock(newBlockEvent: BlockEvent) {
  log.debug('newBlockEvent: ' + JSON.stringify(newBlockEvent));

  const {error, data} = graphql.call("cosmos" as Network, GET_BLOCK, { height: newBlockEvent.height, chain_id: "cosmoshub-4" }, "0.0.1");

  if (error) {
    log.debug('GQL call error: ' + JSON.stringify(error));
    return;
  }

  if (!data) {
    log.debug('GQL call returned no data');
    return;
  }

  log.debug('GQL call data: ' + JSON.stringify(data));

  const { hash, height, time } = data;
  const { id } = newBlockEvent;
  const entity = new BlockEntity({id, hash, height, myNote: "some additional data", time });

  log.debug('Entity: ' + JSON.stringify(entity));

  const {storeErr} = entity.save();
  if (storeErr) {
    log.debug('Error storing block: ' + JSON.stringify(storeErr));
  } else {
    log.debug('Block stored: ' + JSON.stringify(newBlockEvent));
  }
}

var GET_TRANSACTIONS = `query GetTransactions($height: Int = 0, $chain_id: String = "mainnet") {
  transactions(height: $height, chain_id: $chain_id) {
    hash
    height
    time
  }
}`;

function handleTransaction(newTxnEvent: TransactionEvent) {
  const { tx_ids, block_id: blockID } = newTxnEvent;
  const txIDsLen = tx_ids.length;

  log.debug('newTxnEvent: ' + JSON.stringify(newTxnEvent));

  const {error, data} = graphql.call("cosmos" as Network, GET_TRANSACTIONS, { height: newTxnEvent.height, chain_id: "cosmoshub-4" }, "0.0.1");

  if (error) {
    log.debug('GQL call error: ' + JSON.stringify(error));
    return;
  }

  if (!data) {
    log.debug('GQL call returned no data');
    return;
  }

  log.debug('GQL call data: ' + JSON.stringify(data));

  data.transactions.forEach((tx,idx) => {
    if (idx >= txIDsLen) {
      log.debug('Transaction ids slice is too short: ' + txIDsLen);
      return;
    }

    const hash = tx.hash , height = tx.height, time = tx.time;
    const entity = new TransactionEntity({id: tx_ids[idx], blockID, hash, height, myNote: "some additional data", time });

    log.debug('Entity: ' + JSON.stringify(entity));

    const {storeErr} = entity.save();
    if (storeErr) {
      log.debug('Error storing transaction: ' + JSON.stringify(storeErr));
    } else {
      log.debug('Transaction stored: ' + JSON.stringify(newTxnEvent));
    }
  });
}
